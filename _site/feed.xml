<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-01-04T07:48:51-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jean Barkhuysen</title><subtitle>SWE at Netflix working on distributed media processing/storage. Former Googler working on distributed storage. Former surname de Klerk.
This is my personal website. The views represented here are my own, and do not represent my employer.</subtitle><entry><title type="html">Running your own pkgsite, pt1</title><link href="http://localhost:4000/2025/01/03/pkgsite-pt1.html" rel="alternate" type="text/html" title="Running your own pkgsite, pt1" /><published>2025-01-03T00:55:23-07:00</published><updated>2025-01-03T00:55:23-07:00</updated><id>http://localhost:4000/2025/01/03/pkgsite-pt1</id><content type="html" xml:base="http://localhost:4000/2025/01/03/pkgsite-pt1.html"><![CDATA[<h2 id="who-this-is-for">Who this is for</h2>

<p>I’ve recently joined Netflix, and I’m doing a bit of Go. Go is not one of the
main languages at Netflix, so it lacks a dedicated team supporting it, and lacks
some common tooling.</p>

<p>I’ve been particularly missing
<a href="https://pkg.go.dev/golang.org/x/pkgsite">x/pkgsite</a> - the documentation server
behind <a href="https://pkg.go.dev/">pkg.go.dev</a>.</p>

<p>Netflix has a private enterprise GitHub repository and a corresponding private
<a href="https://go.dev/ref/mod#module-proxy">module proxy</a>, so the public pkgsite
doesn’t index it. So, I set out to figure out how to run my own instance of
pkgsite against this private repo &amp; module proxy.</p>

<p>Though pkgsite is open source, there’s no documentation for running it yourself
(probably for good reasons). So, this article is for anyone who wants to do
something similar.</p>

<h2 id="components">Components</h2>

<p>First of all, pkgsite is canonically hosted at https://go.googlesource.com/pkgsite
and can be cloned with <code class="language-plaintext highlighter-rouge">git clone https://go.googlesource.com/pkgsite</code>.</p>

<p>Let’s look at the important components that we’re going to be dealing with.
Here’s a selective look with <code class="language-plaintext highlighter-rouge">tree</code>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>tree
<span class="nb">.</span>
|____cmd
| |____frontend
| | |____main.go
| |____pkgsite
| | |____main.go
| |____worker
| | |____main.go
|____migrations
| |____000073_create_documentation_symbols.down.sql
| |____000018_add_module_version_states_status_index.up.sql
| |____...etc...
|____devtools
| |____cmd
| | |____seeddb
| | | |____seed.txt
| | | |____main.go
</code></pre></div></div>

<p>So, the main programs we’ll run are the frontend, worker, seeddb, and
cmd/pkgsite - the latter of which I’ll refer to as such to disambiguate with
pkgsite, the overall project. The migrations directory hold all the .sql files
needed to set up a postgres database that other components deal with.</p>

<p>Let’s quickly describe each:</p>

<ul>
  <li><strong>cmd/pkgsite</strong>: The simplest and best documented. Running this lets you host
a minimal pkgsite. It’s not connected to a database and doesn’t have a worker
searching for modules. So, it doesn’t have a usable search feature. It’s useful
for looking at one or two of your own projects but without search, it’s not good
enough for an entire org.</li>
  <li><strong>frontend</strong>: The web-serving frontend. When run, serves the frontend at
<code class="language-plaintext highlighter-rouge">localhost:8080</code>.</li>
  <li><strong>worker</strong>: The data-fetching backend that updates the database. When run,
serves a work management page at <code class="language-plaintext highlighter-rouge">localhost:8000</code>.</li>
  <li><strong>migrations</strong>: A series of sql scripts that when run in order will set up
all the necessary tables and schemas.</li>
  <li><strong>seeddb</strong>: A one-shot program that reads a <code class="language-plaintext highlighter-rouge">seed.txt</code> file, fetches modules
listed there-in, and populates the database with the information.</li>
</ul>

<h2 id="modifiable-config">Modifiable config</h2>

<p>The frontend and worker both use <code class="language-plaintext highlighter-rouge">internal/config/serverconfig/config.go</code>, which
is modifiable with environment variables. Let’s look at a subset of important
environment variables that you may want to change when running these programs:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Proxy config.
ProxyURL:   GetEnv("GO_MODULE_PROXY_URL", "https://proxy.golang.org"),

# Database config.
DBHost:               chooseOne(GetEnv("GO_DISCOVERY_DATABASE_HOST", "localhost")),
DBUser:               GetEnv("GO_DISCOVERY_DATABASE_USER", "postgres"),
DBPassword:           os.Getenv("GO_DISCOVERY_DATABASE_PASSWORD"),
DBSecondaryHost:      chooseOne(os.Getenv("GO_DISCOVERY_DATABASE_SECONDARY_HOST")),
DBPort:               GetEnv("GO_DISCOVERY_DATABASE_PORT", "5432"),
DBName:               GetEnv("GO_DISCOVERY_DATABASE_NAME", "discovery-db"),
</code></pre></div></div>

<p>The proxy URL in particular we’ll need to change, since the point of this
project is to run against our own private module proxy. We’ll get into that a
bit later on, but for now just know these exist.</p>

<h2 id="running-a-simple-pkgsite">Running a simple pkgsite</h2>

<p>To wrap up this post, let’s quickly look at how to run a simple pkgsite:</p>

<h2 id="next-up">Next up</h2>

<p>In a next post, we’ll look at how to set up your postgres database and how to
seed it with seeddb.</p>

<p>After that, we’ll finally take a look at how to run worker and frontend in order
to serve your own pkgsite.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Who this is for]]></summary></entry><entry><title type="html">Goodbye Google, Hiya Netflix</title><link href="http://localhost:4000/2025/01/02/goodbye-google.html" rel="alternate" type="text/html" title="Goodbye Google, Hiya Netflix" /><published>2025-01-02T00:55:23-07:00</published><updated>2025-01-02T00:55:23-07:00</updated><id>http://localhost:4000/2025/01/02/goodbye-google</id><content type="html" xml:base="http://localhost:4000/2025/01/02/goodbye-google.html"><![CDATA[<h1 id="a-goodbye-to-google">A goodbye to Google</h1>

<p>I left Google last month, after almost 7 years to the day.</p>

<p>This comes from a desire to switch to remote work, which lets my wife, kids, and
I move closer to our family.</p>

<p>In my farewell letter to the team, I indulged in a bit of a tradition of writing
a retrospective. I don’t think I’ll do so here, but I thought it was worth
putting a marker in ~the sand~ my blog all the same.</p>

<p>I will share the last paragraph, though:</p>

<blockquote>
  <p>I’ve been incredibly lucky to be surrounded by phenomenal managers, team
leads, and incredibly talented peers. I’m indelibly grateful [to each of them].
It has been an immense privilege and pleasure working and learning from [them].</p>
</blockquote>

<p>Working at Google the past 7 years has been a total dream, and I’ve learned an
immense amount from the challenges I’ve been lucky enough to work on, and moreso
the peers I’ve been able to work with.</p>

<h2 id="a-hello-to-netflix">A hello to Netflix</h2>

<p>All that said, I am also very excited for my next chapter at Netflix. I’ve heard
great things about the work that’s done at Netflix and look forward to see
another way to do things, apply some of the things I’ve learned, and no doubt
learn a great deal from the next set of challenges and great colleagues.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[A goodbye to Google]]></summary></entry><entry><title type="html">Engineering resources from Google</title><link href="http://localhost:4000/2022/12/07/google-resources.html" rel="alternate" type="text/html" title="Engineering resources from Google" /><published>2022-12-07T00:55:23-07:00</published><updated>2022-12-07T00:55:23-07:00</updated><id>http://localhost:4000/2022/12/07/google-resources</id><content type="html" xml:base="http://localhost:4000/2022/12/07/google-resources.html"><![CDATA[<h1 id="engineering-resources-from-google">Engineering resources from Google</h1>

<p>This is a collection of extremely useful internal resources, which are made
publicly available. I thought I’d share these, since they are a bit hard to find
externally. And, they really are fantastic - years and years of tweaks and
discussions and refinement have gone into these, from some of the great minds
of computer science.</p>

<p>So, enjoy, as I have:</p>

<h2 id="the-swe-book">The “SWE book”</h2>

<p><a href="https://abseil.io/resources/swe-book">https://abseil.io/resources/swe-book</a></p>

<p>The “SWE book” - Google Engineering Practices Documentation. A classic.</p>

<h2 id="the-sre-book">The “SRE book”</h2>

<p><a href="https://sre.google/sre-book/table-of-contents/">https://sre.google/sre-book/table-of-contents/</a></p>

<p>Another classic, more on the operation side of things.</p>

<h2 id="how-to-code-review">How to code review</h2>

<p><a href="https://google.github.io/eng-practices/">https://google.github.io/eng-practices/</a></p>

<p>The page is called “Google Engineering Practices Documentation” because the
internal version is more broad, but the external version has the bits about how
reviewers and reviewees of code changes should interact. These are <em>fantastic</em>
guidelines for a healthy engineering culture.</p>

<h2 id="the-go-style-guide">The Go style guide</h2>

<p><a href="https://google.github.io/styleguide/go/">https://google.github.io/styleguide/go/</a></p>

<p>How to write “good” Go code at Google. Some of it is convention, but a lot of it
is sensical and very well thought out rules of the road when writing Go code.</p>

<p>(I’m biased, having contributed some of these sections!)</p>

<h2 id="other-language-style-guides">Other language style guides</h2>

<p><a href="https://google.github.io/styleguide/">https://google.github.io/styleguide/</a></p>

<p>Well, I mostly care about Go, hence the callout, but here are the other language
styleguide.</p>

<p>I’ll also call out the C++ as being fantastic. I’ve not used the others as much
but I expect them all to be of a very high quality.</p>

<h1 id="post-note">Post-note</h1>

<p>I will continue editing this article as I find more. Stay tuned!</p>

<p>(I wonder if this will turn into a “How to re-create Google’s engineering department in your company”… 🤔)</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Engineering resources from Google]]></summary></entry><entry><title type="html">Interfaces in depth</title><link href="http://localhost:4000/2022/12/05/interfaces.html" rel="alternate" type="text/html" title="Interfaces in depth" /><published>2022-12-05T00:55:23-07:00</published><updated>2022-12-05T00:55:23-07:00</updated><id>http://localhost:4000/2022/12/05/interfaces</id><content type="html" xml:base="http://localhost:4000/2022/12/05/interfaces.html"><![CDATA[<h2 id="foreword">Foreword</h2>

<p>A conversation with a colleague inspired a deep dive into the refspec, to gain
concrete understanding on some things I had until then only had intuitions
about. I ended up writing nearly an article to that colleague in chat
(sorry colleague…), so I thought I’d take it over the finish line and actually
write the article that my chat message was trying to be.</p>

<p>This is that article.</p>

<h2 id="impetus">Impetus</h2>

<p>This article is inspired by the following confusion:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">myInterface</span> <span class="k">interface</span><span class="p">{</span> <span class="n">hello</span><span class="p">()</span> <span class="p">}</span>
<span class="k">var</span> <span class="n">m1</span> <span class="n">myInterface</span> <span class="o">=</span> <span class="n">implementsMyInterface</span><span class="p">{}</span>
<span class="n">m1</span><span class="o">.</span><span class="n">hello</span><span class="p">()</span> <span class="c">// works!</span>
<span class="k">var</span> <span class="n">m2</span> <span class="o">*</span><span class="n">myInterface</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m1</span>
<span class="n">m2</span><span class="o">.</span><span class="n">hello</span><span class="p">()</span> <span class="c">// does not work</span>
</code></pre></div></div>

<p><a href="https://go.dev/play/p/g56XEBk_OLs">play/p/g56XEBk_OLs</a></p>

<p>The core question is: Why can we use <code class="language-plaintext highlighter-rouge">m1</code>, not <code class="language-plaintext highlighter-rouge">m2</code>?</p>

<p><strong>TLDR</strong>: Go veterans will realise that pointer to interface is an anti-pattern.
It represents kind of a misunderstanding of what’s going on: the user almost
certainly wants a pointer to the <em>struct</em>. Both concrete structs and pointer to
structs can implement interfaces. That’s the intuition I mentioned above. But,
let’s dive into this a bit and figure out what’s behind this.</p>

<h2 id="what-are-interfaces-anyway">What are interfaces, anyway?</h2>

<p>From <a href="https://go.dev/blog/laws-of-reflection">Laws of reflection</a>,</p>

<blockquote>
  <p>A variable of interface type stores a pair: the concrete value assigned to the
variable, and that value’s type descriptor.</p>
</blockquote>

<p>So, I’ll simplify this a bit to the hand-wavy description that an interface type
points to a concrete type. For example, consider an interface type that is
implemented by a struct:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">foo</span> <span class="n">someInterface</span> <span class="o">=</span> <span class="n">someStruct</span><span class="p">{}</span>
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">foo</code> is a variable whose type is <code class="language-plaintext highlighter-rouge">someInterface</code>. Its interface type
“points” (“holds” / “is assigned” / etc) to <code class="language-plaintext highlighter-rouge">someStruct</code>.</p>

<p>Let’s modify that a bit:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">foo</span> <span class="n">someInterface</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">someStruct</span><span class="p">{}</span>
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">foo</code> is a variable whose type is <code class="language-plaintext highlighter-rouge">someInterface</code> which points to a
pointer which points to <code class="language-plaintext highlighter-rouge">someStruct</code>.</p>

<p>Ok… still in normal territory. Now let’s go back to where this question came
from and consider if <code class="language-plaintext highlighter-rouge">foo</code> was of type <code class="language-plaintext highlighter-rouge">*someInterface</code> instead:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">foo</span> <span class="n">someInterface</span> <span class="o">=</span> <span class="n">someStruct</span><span class="p">{}</span>
<span class="k">var</span> <span class="n">bar</span> <span class="n">someInterface</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">someStruct</span><span class="p">{}</span>

<span class="k">var</span> <span class="n">gaz</span> <span class="o">*</span><span class="n">someInterface</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span> <span class="c">// bad</span>
<span class="k">var</span> <span class="n">urk</span> <span class="o">*</span><span class="n">someInterface</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bar</span> <span class="c">// also bad</span>
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">gaz</code> and <code class="language-plaintext highlighter-rouge">urk</code> are pointers to an interface. That’s almost certainly user
error. Pointers to structs are useful,</p>

<ul>
  <li>They allow us to avoid copying when passing structs around.</li>
  <li>They allow us to modify and persist struct state.</li>
</ul>

<p>But, what does a pointer to an interface type give us? Nothing!</p>

<ul>
  <li>An interface type is already a type of pointer as it is, so there’s no copying
when we pass it around.</li>
  <li>An interface type has no state itself. Its implementing type - a struct - can,
but not the interface itself. So there’s no modify/persist state benefit.</li>
</ul>

<h2 id="interfaces-behave-different-than-structs">Interfaces behave different than structs</h2>

<p>Ok, so we’ve talked about how interfaces are fundamentally different, and that
variables conceptually should (usually) not use interface pointer types; in
constrast to structs, where pointers to structs are very common and useful.</p>

<p>Now let’s look at how struct and interface types behave differently with regards
to pointer referencing and dereferencing. Let’s do so by collecting together a
few facts about interfaces from the refspec, to prepare for our conclusion:</p>

<h3 id="a-struct-can-implement-an-interface-with-concrete-or-pointer-method-receivers">A struct can implement an interface with concrete or pointer method receivers</h3>

<p>A struct can implement an interface with either concrete or pointer method
receivers. Per
<a href="https://go.dev/ref/spec#Interface_types">ref/spec#Interface_types</a>, there’s no
way to specify concrete or pointer method receiver in an interface. (indeed,
it’s moot to the interface: the interface defines, well, the interface, not the
implementation details)</p>

<p>Concretely, both these structs implement the interface:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">myInterface</span> <span class="k">interface</span><span class="p">{</span> <span class="n">hello</span><span class="p">()</span> <span class="p">}</span>

<span class="k">type</span> <span class="n">concreteMethodReceivers</span> <span class="k">struct</span><span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="n">concreteMethodReceivers</span><span class="p">)</span> <span class="n">hello</span><span class="p">()</span> <span class="p">{}</span>

<span class="k">type</span> <span class="n">pointerMethodReceivers</span> <span class="k">struct</span><span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">pointerMethodReceivers</span><span class="p">)</span> <span class="n">hello</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div>

<p><a href="https://go.dev/play/p/sjU9d72ZWzw">play/p/sjU9d72ZWzw</a></p>

<h3 id="selectors-automatically-dereference-pointers-to-structs">Selectors automatically dereference pointers to structs</h3>

<p>Selectors automatically dereference pointers to structs <a href="https://go.dev/ref/spec#Method_values">ref/spec#Method_values</a>:</p>

<blockquote>
  <p>As with selectors, a reference to a non-interface method with a value receiver using a pointer will automatically dereference that pointer: pt.Mv is equivalent to (*pt).Mv.</p>
</blockquote>

<p>So, for implementing interfaces:</p>

<ul>
  <li>If you have a struct that implements the interface with
<em>concrete method receivers</em>, you can use either concrete struct or pointer
to your struct as type for interface (latter will be de-referenced).</li>
  <li>If you have a struct that implements the interface with
<em>pointer method receivers</em>, you have to use pointer to your struct as type
for interface (concrete struct <em>won’t</em> be automatically turned to pointer).</li>
</ul>

<p>Concretely:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">f1</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">concreteMethodReceiverStruct</span><span class="p">{}</span>
<span class="n">f1</span><span class="o">.</span><span class="n">Hello</span><span class="p">()</span> <span class="c">// works</span>

<span class="k">var</span> <span class="n">f2</span> <span class="n">foo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">concreteMethodReceiverStruct</span><span class="p">{}</span>
<span class="n">f2</span><span class="o">.</span><span class="n">Hello</span><span class="p">()</span> <span class="c">// works</span>

<span class="k">var</span> <span class="n">f3</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">pointerMethodReceiverStruct</span><span class="p">{}</span>
<span class="n">f3</span><span class="o">.</span><span class="n">Hello</span><span class="p">()</span> <span class="c">// does not work</span>

<span class="k">var</span> <span class="n">f4</span> <span class="n">foo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pointerMethodReceiverStruct</span><span class="p">{}</span>
<span class="n">f4</span><span class="o">.</span><span class="n">Hello</span><span class="p">()</span> <span class="c">// works</span>
</code></pre></div></div>

<p><a href="https://go.dev/play/p/aWQ8C2-SwZ2">play/p/aWQ8C2-SwZ2</a></p>

<h3 id="pointers-to-interfaces-do-not-automatically-dereference">Pointers to interfaces do not automatically dereference</h3>

<p>Pointers to interfaces do not automatically dereference, like pointers to
structs do. (they used to in pre-Go1, fwiw; <a href="https://groups.google.com/g/golang-nuts/c/RhIIHM3XC4o">g/golang-nuts/c/RhIIHM3XC4o</a>)</p>

<p>Concretely:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">thing</span> <span class="n">myInterface</span> <span class="o">=</span> <span class="n">myStruct</span><span class="p">{}</span>
<span class="n">thing</span><span class="o">.</span><span class="n">Whatever</span><span class="p">()</span> <span class="c">// works</span>
<span class="k">var</span> <span class="n">thing2</span> <span class="o">*</span><span class="n">myInterface</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">thing</span>
<span class="n">thing2</span><span class="o">.</span><span class="n">Whatever</span><span class="p">()</span> <span class="c">// does not work</span>
</code></pre></div></div>

<p><a href="https://go.dev/play/p/9QBQmO4-nZN">play/p/9QBQmO4-nZN</a></p>

<h2 id="putting-it-all-together">Putting it all together</h2>

<p>So, let’s talk about the various ways you can declare and use an <strong>interface</strong>.
As mentioned before and shown with
<a href="https://go.dev/play/p/aWQ8C2-SwZ2">play/p/aWQ8C2-SwZ2</a>:</p>

<ul>
  <li>✅ can implement interface with concrete type method receiver + concrete type</li>
  <li>✅ can implement interface with concrete type method receiver + pointer type (<em>auto de-reference</em>)</li>
  <li>❌ can implement interface with pointer type method receiver + concrete type (<em>no auto reference</em>)</li>
  <li>✅ can implement interface with pointer type method receiver + pointer type</li>
</ul>

<p>Now, let’s contrast that with the various ways that you can declare and use a
<strong>struct</strong>. As shown with
<a href="https://go.dev/play/p/IfD0MGTLT_n">play/p/IfD0MGTLT_n</a> and spelled out in
<a href="https://go.dev/ref/spec#Method_values">ref/spec#Method_values</a>:</p>

<ul>
  <li>✅ can call concrete type method receiver with concrete type</li>
  <li>✅ can call pointer type method receiver with concrete type (<em>auto reference</em>)</li>
  <li>✅ can call concrete type method receiver with pointer type (<em>auto de-reference</em>)</li>
  <li>✅ can call pointer type method receiver with pointer type</li>
</ul>

<p>So, the rules for structs and interfaces are different, to prevent interface
mis-use.</p>

<h2 id="afterword">Afterword</h2>

<p>You can read more about how interfaces are represented here:</p>

<ul>
  <li><a href="https://research.swtch.com/interfaces">Go Data Structures: Interfaces</a> by rsc@</li>
  <li><a href="https://www.airs.com/blog/archives/277">Go Interfaces</a> by iant@</li>
  <li><a href="https://go.dev/blog/laws-of-reflection">Laws of Reflection</a> by r@</li>
</ul>]]></content><author><name></name></author><summary type="html"><![CDATA[Foreword]]></summary></entry><entry><title type="html">Graceful degradation with the logistic function</title><link href="http://localhost:4000/2022/05/05/logistic-function-backoff.html" rel="alternate" type="text/html" title="Graceful degradation with the logistic function" /><published>2022-05-05T15:55:23-06:00</published><updated>2022-05-05T15:55:23-06:00</updated><id>http://localhost:4000/2022/05/05/logistic-function-backoff</id><content type="html" xml:base="http://localhost:4000/2022/05/05/logistic-function-backoff.html"><![CDATA[<h1 id="graceful-degradation-with-the-logistic-function">Graceful degradation with the logistic function</h1>

<p>I recently worked on a server throttling feature in one of our build stack’s busiest binaries. We serve files from this binary, which is deployed as tens of thousands of tasks, which cumulatively serve millions of QPS.</p>

<p>Sometimes, one of these tasks gets a large memory spike. The cause for this is that the task is asked to hold a single file, and before it gets replicated, the file is needed by tens of thousands of peers, who all bombard the task with RPCs. Handling all these requests causes a huge spike in memory, and the task falls over.</p>

<p>Eventually replication catches up, and there are enough peers to spread the load. But we’d like to fail more gracefully than just OOM =&gt; death. We’d like to monitor the current and allocated memory, and gradually reject requests (throttle) when current memory exceeds allocated memory.</p>

<h1 id="abrupt-degradation">Abrupt degradation</h1>

<p>A simple way to abruptly degrade is to reject requests above the allocated amount. We can model that with a simple step function. For the sake of example, let’s imagine that our allocated memory is <code class="language-plaintext highlighter-rouge">3GiB = 3221225472 bytes</code>. We don’t want to hit 3GiB exactly, since that’s roughly where we’ll OOM, so let’s start throttling a bit before that: at <code class="language-plaintext highlighter-rouge">3000000000 bytes = 3e9 bytes</code> (number chosen because it’s conveniently round, and close to 3GiB 🙂).</p>

\[f(x) = \left\{
        \begin{array}{ll}
            1 &amp; \quad x \ge 3e9 \\
            0 &amp; \quad x &lt; 3e9
        \end{array}
    \right.\]

<p>Here, 0 means “don’t reject”, and 1 means “reject”.</p>

<p>But, this is inefficient: we’re not using all our available memory. In a resource constrained environment, or when we’re highly scaled, we really want to squeeze every bit of memory that we can, and leaving a huge buffer untouched is far too wasteful.</p>

<h1 id="gradual-degradation">Gradual degradation</h1>

<p>It’s starting to sound like we need a linear function, not a stepwise function: something that rejects more and more requests the more memory we’re using. We now need a range to operate our throttler within: at the bottom of the range, we reject no requests; at the top, all requests.</p>

<p>Let’s define our range as <code class="language-plaintext highlighter-rouge">[3e9 bytes, 3221225472 bytes]</code>, using the same bounds as our step function above.</p>

<p>So, let’s build a linear function for this. Note that the values that we want from our linear function are <code class="language-plaintext highlighter-rouge">[0.0, 1.0]</code>. As above, 0 means “don’t reject”, and 1 means “reject”. Any value between that represents that chance that a request will be rejected. That is, we’ll compare the result of our linear function against a number taken randomly from a uniform distribution of <code class="language-plaintext highlighter-rouge">[0.0, 1.0]</code>.</p>

<p>To build this linear function, let’s start with what we know:</p>

<ul>
  <li>Linear functions look like $f(x)=a \cdot x + b$</li>
  <li>$f(3e9)=0$</li>
  <li>$f(3221225472)=1$</li>
</ul>

<p>We can use this to solve the equation:</p>

\[\begin{split}
0 = a \cdot 3e9 + b\\
-b = 3e9 \cdot a\\
b = -3e9 \cdot a
\end{split}
\quad\quad
\begin{split}
1 = a \cdot 3221225472 + b\\
1 - b = a \cdot 3221225472\\
-b = a \cdot 3221225472 - 1\\
b = -a \cdot 3221225472 + 1
\end{split}\\ \text{ } \\ \text{ } \\
-3e9 \cdot a = -a \cdot 3221225472 + 1 \\
-3e9 \cdot a + a \cdot 3221225472 = 1 \\
a \cdot (-3e9 + 3221225472) = 1 \\
a = 1/221225472\]

<p>Now that we know <code class="language-plaintext highlighter-rouge">a</code>, let’s use that and either of the two partial solutions above to find <code class="language-plaintext highlighter-rouge">b</code>:</p>

\[1 = a \cdot 3221225472 + b\\
1 = 3221225472/221225472 + b\\
b = 1 - 3221225472/221225472\\
b = -1953125/144027\]

<p>Our stepwise function accordingly gets an embedded linear function:</p>

\[f(x) = \left\{
        \begin{array}{ll}
            x/221225472 - 1953125/144027  &amp; \quad x \ge 3e9 \\
            0 &amp; \quad x &lt; 3e9
        \end{array}
    \right.\]

<p><img src="/assets/linear.png" alt="" /></p>

<p>We can verify that this works by plugging in our original numbers:</p>

\[\begin{split}
f(x) = x/221225472 - 1953125/144027\\
f(x) = 3e9/221225472 - 1953125/144027\\
f(x) = 0
\end{split}
\quad\quad
\begin{split}
f(x) = x/221225472 - 1953125/144027\\
f(x) = 3221225472/221225472 - 1953125/144027\\
f(x) = 1
\end{split}\\\]

<h1 id="linear-function-downsides">Linear function downsides</h1>

<p>This is a lot nicer, but we can do better. If our binary is <em>expected</em> to consistently “run hot” (use most of its allocated memory), the linear function may be too aggressive.</p>

<p>Consider a binary that fairly consistently runs somewhere in the bottom 10-30% of the throttle memory range. A linear function will accordingly throttle 10-30% of requests. That’s expensive! Particularly if the incoming RPCs have a wide range of memory footprints: throttling 10-30% of requests when those requests may have negligible impact on memory is wasteful. And we can’t just make our memory range smaller. Doing so is dangerous: the smaller the range, the easier it is for a request to cause our memory to jump to the end of the range and OOM the process.</p>

<p>And, the second half of the linear function range is a problem too: it ramps up too slowly! When we’re 90% into our range, we’d like to be throttling most all requests, since it may only take a few expensive requests to jump right to the end and OOM the process.</p>

<p>We need to find a function with a better shape.</p>

<h1 id="graceful-degradation">Graceful degradation</h1>

<p>The <a href="https://en.wikipedia.org/wiki/Logistic_function">logistic function</a> has a better shape for server throttling.</p>

<p>Here’s the shape of the logistic function:</p>

<p><img src="/assets/logistic.png" alt="" /></p>

<p>Its S-shaped curve allows more requests through when we’re at the bottom of our range, and aggressively throttles at the end of our range.</p>

<p>The equation for the logistic function is as follows,</p>

\[\begin{align*}
f(x) = \dfrac{L}{1 + e^{-k(x-x_0)}}
\end{align*}\]

<p>Where,</p>

<ul>
  <li>$x_0$ is the x value of the sigmoid’s midpoint</li>
  <li>L is the curve’s maximum value</li>
  <li>k is the logistic growth rate or steepness of the curve</li>
</ul>

<p>Let’s adapt this to our problem:</p>

<p>L is the easiest: we want the maximum value to be 1 (we want our range to be <code class="language-plaintext highlighter-rouge">[0.0, 1.0]</code>), So, <code class="language-plaintext highlighter-rouge">L=1</code>.</p>

<p>$x_0$ is fairly straightforward: the midpont should be the midpoint between the start and end of our range. So,</p>

\[\begin{align}
x_0 = 3221225472-\left(\dfrac{3221225472-3e9}{2}\right)\\
x_0 = 3110612736
\end{align}\]

<p>Now we have,</p>

\[\begin{align*}
f(x) = \dfrac{L}{1 + e^{-k(x-x_0)}}\\
f(x) = \dfrac{1}{1 + e^{-k(x-3110612736)}}
\end{align*}\]

<p>k is the hardest. Let’s start by solving for k in the equation above:</p>

\[\begin{align*}
f(x) = \dfrac{1}{1 + e^{-k\left(x-3110612736\right)}}\\
f(x)\left(1 + e^{-k(x-3110612736)}\right) = 1\\
1 + e^{-k(x-3110612736)} = \dfrac{1}{f(x)}\\
e^{-k(x-3110612736)} = \dfrac{1}{f(x)}-1\\
-k(x-3110612736) = ln\left(\dfrac{1}{f(x)}-1\right)\\
k(x-3110612736) = -ln\left(\dfrac{1}{f(x)}-1\right)\\
k = \dfrac{-ln\left(\dfrac{1}{f(x)}-1\right)}{x-3110612736}\\
\end{align*}\]

<p>Now we return to what we know about how this curve <em>should</em> behave:</p>

<ul>
  <li>$f(3e9)=0$</li>
  <li>$f(3221225472)=1$</li>
</ul>

<p>Unfortunately, using either of these results in an unsolvable equation:</p>

\[\begin{split}
k = \dfrac{-ln\left(\dfrac{1}{f(x)}-1\right)}{x-3110612736}\\
k = \dfrac{-ln\left(\dfrac{1}{0}-1\right)}{3e9-3110612736}\\
\text{NaN: can't divide by 0}
\end{split}
\quad\quad
\begin{split}
k = \dfrac{-ln\left(\dfrac{1}{f(x)}-1\right)}{x-3110612736}\\
k = \dfrac{-ln\left(\dfrac{1}{1}-1\right)}{3221225472-3110612736}\\
k = \dfrac{-ln(0)}{3221225472-3110612736}\\
\text{NaN: natural log of 0 is undefined}
\end{split}\]

<p>So, that’s a bummer. But it makes sense: the logistic function is asymptotic, with asymptotes 0 and 1: it will never actually reach those values!</p>

<p>So, let’s estimate k by choosing a value close to the asymptotes: either .01 for the lower bound, or .99 for the upper bound. It doesn’t matter which one we do, as the curve is reflected around the midpoint. So, let’s use the upper:</p>

\[k = \dfrac{-ln\left(\dfrac{1}{f(x)}-1\right)}{x-3110612736}\\
k = \dfrac{-ln\left(\dfrac{1}{.99}-1\right)}{3221225472-3110612736}\\
k = \dfrac{-ln(0.0101010101)}{110612736}\\
k = \dfrac{4.59511985023}{110612736}\\
k = \dfrac{4.595119}{110612736}\\
k = .0000000415424043\]

<p>Great! Let’s put it all together:</p>

\[\begin{align*}
f(x) = \dfrac{L}{1 + e^{-k(x-x_0)}}\\
f(x) = \dfrac{1}{1 + e^{-.0000000415424043(x-3110612736)}}
\end{align*}\]

<p><img src="/assets/logistic_real.png" alt="" /></p>

<p>We can verify that this works by plugging in our original numbers:</p>

\[\begin{split}
f(x) = \dfrac{1}{1 + e^{-.0000000415424043(x-3110612736)}}\\
f(x) = \dfrac{1}{1 + e^{-.0000000415424043(3e9-3110612736)}}\\
f(x) = 0.01000000841
\end{split}
\quad\quad
\begin{split}
f(x) = \dfrac{1}{1 + e^{-.0000000415424043(x-3110612736)}}\\
f(x) = \dfrac{1}{1 + e^{-.0000000415424043(3221225472-3110612736)}}\\
f(x) = 0.98999999158
\end{split}\\\]

<p>Since we’re approximating values and will never reach 0 or 1, it’s helpful to continue using the stepwise function to guarantee no throttling when we’re below our threshold, and to always throttle when we’re above our allowable range:</p>

\[f(x) = \left\{
        \begin{array}{ll}
            1 &amp; \quad x \ge 3221225472 \\
            \dfrac{1}{1 + e^{-.0000000415424043(x-3110612736)}}  &amp; \quad 3e9 \le x &lt; 3221225472  \\
            0 &amp; \quad x &lt; 3e9
        \end{array}
    \right.\]

<h1 id="implementing-logistic-function-server-throttling">Implementing logistic function server throttling</h1>

<p>Implementing server throttling with the logistic function is fairly straight forward, adding another positive to its list of positives:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// This example written in Go. It uses RPC semantics, like protobufs and</span>
<span class="c">// google.golang.org/grpc/status, but the tools don't really matter. http or any</span>
<span class="c">// other communication protocol works as well.</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Client</span><span class="p">)</span> <span class="n">HandleSomeRPC</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">req</span> <span class="o">*</span><span class="n">mypb</span><span class="o">.</span><span class="n">Request</span><span class="p">,</span> <span class="n">resp</span> <span class="o">*</span><span class="n">mypb</span><span class="o">.</span><span class="n">Response</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">shouldThrottle</span><span class="p">(</span><span class="n">currentMemoryBytes</span><span class="p">(),</span> <span class="n">allocatedMemoryBytes</span><span class="p">(),</span> <span class="n">throttleRangeBytes</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">status</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="n">codes</span><span class="o">.</span><span class="n">ResourceExhausted</span><span class="p">,</span> <span class="s">"out of memory - try again later"</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c">// ...</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">shouldThrottle</span><span class="p">(</span><span class="n">currentMemoryBytes</span><span class="p">,</span> <span class="n">allocatedMemoryBytes</span><span class="p">,</span> <span class="n">throttleRangeBytes</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">currentMemoryBytes</span> <span class="o">&lt;</span> <span class="n">allocatedMemoryBytes</span><span class="o">-</span><span class="n">throttleRangeBytes</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">false</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="n">currentMemoryBytes</span> <span class="o">&gt;</span> <span class="n">allocatedMemoryBytes</span><span class="o">+</span><span class="n">throttleRangeBytes</span> <span class="p">{</span>
		<span class="c">// Relevant if your process is in a scenario where max available memory</span>
		<span class="c">// is greater than max allocated memory (shared containers etc).</span>
		<span class="k">return</span> <span class="no">true</span>
	<span class="p">}</span>

	<span class="n">x</span> <span class="o">:=</span> <span class="n">currentMemoryBytes</span>
	<span class="n">x0</span> <span class="o">:=</span> <span class="n">allocatedMemoryBytes</span> <span class="o">-</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">)(</span><span class="n">throttleRangeBytes</span><span class="o">/</span><span class="m">2</span><span class="p">)</span>
	<span class="n">L</span> <span class="o">:=</span> <span class="m">1.0</span>
	<span class="n">k</span> <span class="o">:=</span> <span class="p">(</span><span class="o">-</span><span class="m">1</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">Log</span><span class="p">((</span><span class="n">L</span><span class="o">/</span><span class="m">.01</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="kt">float64</span><span class="p">)(</span><span class="n">allocatedMemoryBytes</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span>

	<span class="c">// y1 is probability (0.00-1.00) which we roll against to determine whether</span>
	<span class="c">// to throttle or not. When it is 0, we never throttle (memory below allowed</span>
	<span class="c">// exceed). When it is 1, we always throttle (memory above allowed exceed).</span>
	<span class="n">y1</span> <span class="o">:=</span> <span class="n">L</span> <span class="o">/</span> <span class="p">(</span><span class="m">1.0</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">Exp</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="kt">float64</span><span class="p">)(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)))</span>

	<span class="c">// y2 is a number between 0 and 1 to compare against y1.</span>
	<span class="n">y2</span> <span class="o">:=</span> <span class="n">rand</span><span class="o">.</span><span class="n">Float64</span><span class="p">()</span>

	<span class="k">return</span> <span class="n">y2</span> <span class="o">&lt;=</span> <span class="n">y1</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="conclusion">Conclusion</h1>

<p>At tremendous scale, it’s important to eke every last bit of memory from servers. It’s also important to be able to gracefully degrade during memory spikes, to avoid out-of-memory crashes. The logistic function is an excellent function for deciding whether to throttle requests, which strikes a good balance between the competing priorities of using all available memory and avoiding out-of-memory crashes.</p>

<script type="text/javascript" async="" src="/assets/MathJax-2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      },
      extensions: [
        "MathMenu.js",
        "MathZoom.js",
        "AssistiveMML.js"
      ],
      jax: ["input/TeX", "output/CommonHTML"],
      TeX: {
        extensions: [
          "AMSmath.js",
          "AMSsymbols.js",
          "noErrors.js",
          "noUndefined.js",
        ]
      }
    });
  </script>]]></content><author><name></name></author><summary type="html"><![CDATA[Graceful degradation with the logistic function]]></summary></entry><entry><title type="html">Wrapped errors are stacks</title><link href="http://localhost:4000/2022/02/09/wrapped-errors-are-stacks.html" rel="alternate" type="text/html" title="Wrapped errors are stacks" /><published>2022-02-09T14:55:23-07:00</published><updated>2022-02-09T14:55:23-07:00</updated><id>http://localhost:4000/2022/02/09/wrapped-errors-are-stacks</id><content type="html" xml:base="http://localhost:4000/2022/02/09/wrapped-errors-are-stacks.html"><![CDATA[<h1 id="wrapped-errors-are-stacks">Wrapped errors are stacks</h1>

<p>Wrapping an error creates a stack: a linked list of error pointing to the next error, where newly wrapped errors are added to the head, and the stack is traversed from head to tail during As, Is, and with the Unwrap interface.</p>

<p>It’s important to keep this in mind when you’re designing the internal representation for your unwrappable structured error. The simplest representation is a single error:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type decompressErr struct {
  name string
  err error // Points to the next error down the stack.
}

func (e *decompressErr) Error() string {
  return fmt.Sprintf("decompress %s: %s", e.name, e.err)  
}

func (e *decompressErr) Unwrap() error { return e.err }
</code></pre></div></div>

<p>Most unwrappable structured errors should only contain a single error. They have obvious semantics and are easy to use.</p>

<p>Unwrappable structured errors that contain multiple errors have much less clear semantics. Consider:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// We recommend against this approach.
type PathParseErrors struct {
  // A map of path to parse error for that path.
  errors map[string]error
}

func (e *PathParseErrors) Error() string {
  return fmt.Sprintf("%v", e.errors)
}

func (e *PathParseErrors) Unwrap() error {
  // Nothing we return here will be obvious.
}
</code></pre></div></div>

<p>In this example, the stack semantics are broken: we have an unwrappable structured error that contains a map of errors. But, which error will Unwrap return? There’s no right answer: any choice would be non-obvious to the user. A slice has the same issue as a map: there’s no obvious error to return.</p>

<p>This issue is exacerbated by the fact that it’s impossible for the author of PathParseErrors to document their Unwrap method in a way that will directly help users. Users often don’t interact with the Unwrap method directly: they use tools like As and Is, which themselves call the Unwrap method. And, this error may exist in a library that is several layers deep in a dependency tree: a user may have a very hard time finding the exact library whose documentation to go read when they’ve got an opaque stack of wrapped errors.</p>

<p>When you need to collect several errors at once, use <code class="language-plaintext highlighter-rouge">[]error</code>, a map of errors, or a structured error that does not support Unwrap.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Wrapped errors are stacks]]></summary></entry><entry><title type="html">Don’t use assertion libraries in Go</title><link href="http://localhost:4000/2022/02/08/assertion-libraries.html" rel="alternate" type="text/html" title="Don’t use assertion libraries in Go" /><published>2022-02-08T14:55:23-07:00</published><updated>2022-02-08T14:55:23-07:00</updated><id>http://localhost:4000/2022/02/08/assertion-libraries</id><content type="html" xml:base="http://localhost:4000/2022/02/08/assertion-libraries.html"><![CDATA[<p>Foreword #1: This is a very sensitive topic for many people. 🙂 I find that many people have never considered writing tests <em>without</em> assertion libraries. It might come as a shocking surprise to consider such a world. That shock and surprise might be painful. Steel yourself.</p>

<p>Foreword #2: This is inspired by a long conversation the Google Go readability crowd recently, in which we collectively re-affirmed our position to ban assertion libraries in Google. Most of this post is my own responses, tidied up.</p>

<h1 id="just-stop">Just stop</h1>

<p>Assertion libraries are libraries that attempt to combine the validation and production of failure messages within a test.</p>

<p>This post is not about mocking libraries, or comparison libraries. It is about assertion libraries. Examples of assertion libraries include <a href="https://pkg.go.dev/github.com/stretchr/testify">github.com/stretchr/testify</a>, <a href="https://pkg.go.dev/github.com/onsi/ginkgo">github.com/onsi/ginkgo</a>, <a href="https://pkg.go.dev/gopkg.in/check.v1">gopkg.in/check.v1</a>, and <a href="https://pkg.go.dev/github.com/franela/goblin">github.com/franela/goblin</a>.</p>

<p>Don’t use these things. They provide little value over the stdlib, and tend to make your codebase (far) less readable. Use <a href="https://pkg.go.dev/testing">“testing”</a> for assertions, and comparison libraries like <a href="https://pkg.go.dev/github.com/google/go-cmp/cmp">github.com/google/go-cmp/cmp</a> to perform the comparison (but not <em>the assertion</em>) for more complex objects that can’t be compared with basic operators (<code class="language-plaintext highlighter-rouge">==</code>, <code class="language-plaintext highlighter-rouge">&gt;</code>, etc).</p>

<p>Sidenote: The <a href="https://pkg.go.dev/testing">testing</a> library is also an assertion library, but for the sake of this article we’ll just call it “the stdlib” or “testing”, and refer to all the non-stdlib assertion libraries as “assertion libraries”.</p>

<h1 id="assertion-libraries-bring-incomprehensibility">Assertion libraries bring incomprehensibility</h1>

<p>Consider the following Java code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>assertParagraphElement(bodyStructuralElements.get(25).getParagraph().getElements().get(0), 311, 312, Person.class);
</code></pre></div></div>

<p>What the heck is going on here? I have no freaking idea what this line is asserting. This is <em>real code</em> pulled from a <em>real codebase</em> owned by a well respected team. It’s incomprehensible.</p>

<p>Let me show you another one, in C++ this time:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> EXPECT_CALL(
        *mock_quota_server_client_,
        MultiGetTokens(
            ::testing::AllOf(
                ::testing::AllOfArray(
                    experiment_ids |
                    ::websitetools::feeds::range::transformed(
                        [quota_group_suffix](ExperimentId experiment_id) {
                          return dos_quotas::HasRequest(
                              absl::StrFormat(kQuotaExperimentGroupId,
                                              quota_group_suffix),
                              absl::StrFormat("%s:%d",
                                              kQuotaUserId,
                                              experiment_id));
                        })),
                dos_quotas::HasRequest(
                    absl::StrFormat(kQuotaUserGroupId, quota_group_suffix),
                    kQuotaUserId)),
            _, _))
        .Times(times);
</code></pre></div></div>

<p>Again, real code. Respectable team. Completely incomprehensible.</p>

<p>(editorial note: I’m using Java and C++ code because when I wrote my emails, I wanted to compare sister languages in Google - which do allow assertion libraries - with Go in Google, which does not. Confusing examples like these are fairly easy to search for on GitHub)</p>

<p>The thing with assertion libraries is that it’s never just <code class="language-plaintext highlighter-rouge">assert.Equal(a, b)</code>, like the advertisement purports. There is a continual gravity towards complexity. There are <a href="https://pkg.go.dev/github.com/stretchr/testify/assert"><em>277 assertions in the testify library, as of this writing</em></a>. 277!!!! That’s before you even get into <a href="https://pkg.go.dev/github.com/stretchr/testify/assert">making your own assertions</a>. By the way, the likelihood of your developers - and you! - writing custom assertions approaches 100% as your codebase grows over time. In my experience it approaches 100% awfully quickly; we’re talking a few weeks.</p>

<h1 id="assertion-libraries-dont-provide-value">Assertion libraries don’t provide value</h1>

<p>Let’s take a look at the examples on the testify front page:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// assert equality
assert.Equal(t, 123, 123, "they should be equal")

// assert inequality
assert.NotEqual(t, 123, 456, "they should not be equal")

// assert for nil (good for errors)
assert.Nil(t, object)

// assert for not nil (good when you expect something)
if assert.NotNil(t, object) {
    // now we know that object isn't nil, we are safe to make
    // further assertions without causing any errors
    assert.Equal(t, "Something", object.Value)
}
</code></pre></div></div>

<p>Seems super valuable, right? Well, not really. Let’s see what it’s like to rewrite those with the “testing” package:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// assert equality
if 123 != 123 {
    t.Errorf("they should be equal")
}

// assert inequality
if 123 == 456 {
    t.Errorf("they should not be equal")
}

// assert for nil (good for errors)
if object == nil {
    t.Errorf("...")
}

// assert for not nil (good when you expect something)
// (and make further assertions without causing errors, because multi-clause conditionals are a thing)
if object != nil &amp;&amp; object.Value != "Something" {
    t.Errorf("...")
}
</code></pre></div></div>

<p>Wow, we sure saved ourselves there from the dreaded <em>if statement</em>! Ok, maybe that’s a bit too much sarcasm. 🙂</p>

<p>As you can see, ordinary Go code works just fine. Detractors will say, “it turns 1 line of code into 3” - and they’re right! I would say that’s a fair trade. Because what we gain in return is:</p>

<ul>
  <li>Very clear understanding of when we t.Error vs t.Fatal.</li>
  <li>Very clear understanding of what our error messages will be; and the ability to customise them.</li>
  <li>A tight, and very low bound on the complexity of our test assertions. It’s just ordinary Go code!</li>
  <li>Readers don’t have to have knowledge of your testing framework to read the code. They just need to understand Go. It’s just ordinary Go code!</li>
</ul>

<p>As you consider these advantages of using ordinary Go code over assertion libraries consider who your code is for. Are you writing personal code, for yourself, that nobody will ever look at? Probably not: more than likely you’re writing code for a team, or a company; it will be maintained for a while, maybe even after your tenure.</p>

<p>Remember: most code gets read far more than the time it took to write it. Optimise for the reader, not the writer. (<a href="https://www.goodreads.com/quotes/835238-indeed-the-ratio-of-time-spent-reading-versus-writing-is">1</a>, <a href="https://devblogs.microsoft.com/oldnewthing/20070406-00/?p=27343">2</a>)</p>

<h1 id="random-other-musings-on-the-subject">Random other musings on the subject</h1>

<p>Two quick notes I wanted to pick out of my emails, but which I couldn’t fit anywhere above:</p>

<ul>
  <li>
    <p>Ruby is another good case study, btw: first you have to learn the language, then you have to learn the craaaaazy amount of magic in rails, activerecord, and the testing libraries - surprisingly little of which overlaps. It is shockingly slow to get going from scratch in ruby because of the many layers of magic. Building a team or a company around languages (and in this case, libraries) which dramatically reduce productivity just make no sense to me.</p>
  </li>
  <li>
    <p>We get into some real contentious space here, but just to throw it out there: DRY is not always a great north star, and has many times been shown to be unhelpful. Don’t optimise your codebase for one line zingers. Optimise them for someone 5 years from now with no context coming in and having to debug an issue.</p>
  </li>
</ul>

<h1 id="conclusion">Conclusion</h1>

<p>Don’t use assertion libraries. You don’t need them. You never have. You’ve been optimising your codebase for 1 line zingers but making it less readable and more incomprehensible, which slows down debugging and slows down future maintainers.</p>

<p>Use “testing”. It has all you need.</p>

<p>Use “cmp” and other comparison libraries if you need to do more complex comparisons (on structs, for example).</p>

<p>Don’t use assertion libraries.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Foreword #1: This is a very sensitive topic for many people. 🙂 I find that many people have never considered writing tests without assertion libraries. It might come as a shocking surprise to consider such a world. That shock and surprise might be painful. Steel yourself.]]></summary></entry><entry><title type="html">Error unwrapping for library authors</title><link href="http://localhost:4000/2022/02/08/error-unwrapping.html" rel="alternate" type="text/html" title="Error unwrapping for library authors" /><published>2022-02-08T14:55:23-07:00</published><updated>2022-02-08T14:55:23-07:00</updated><id>http://localhost:4000/2022/02/08/error-unwrapping</id><content type="html" xml:base="http://localhost:4000/2022/02/08/error-unwrapping.html"><![CDATA[<h1 id="introduction">Introduction</h1>

<p>In https://go.dev/blog/go1.13-errors, Go introduced new language changes that improved how errors are handled in Go programs. These changes include the concept of wrapping errors, as well as tools and semantics for unwrapping errors. They have enabled a rich ecosystem of detailed errors, and given users more ways to examine errors..</p>

<p>Having had a few years to learn about how these tools can be used, let’s discuss some of the subtleties of wrapping and unwrapping, with an eye towards compatibility of our APIs. Accordingly, this article is particularly relevant to library authors, as we will often view wrapped errors through the lens of API compatibility.</p>

<h1 id="wrapped-errors-are-part-of-your-public-api">Wrapped errors are part of your public API</h1>

<p>In “Working with Errors in Go 1.13”, the authors wrote that “When adding additional context to an error, either with fmt.Errorf or by implementing a custom type, you need to decide whether the new error should wrap the original.”. There are numerous considerations that factor into whether to wrap an error, but library authors should specifically consider that wrapped errors become part of their public API.</p>

<p>Let’s re-examine one of the examples from that article:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func Decompress(name, path string) error {
  // ...
  if err != nil {
    return fmt.Errorf("decompress %v: %v", name, err)
  }
  // ...
</code></pre></div></div>

<p>When we write error returns like this in our public APIs, users are given textual information but no structured information. They have no way of inspecting more than the string contents of the error handed to them: as the article states, “Creating a new error with fmt.Errorf discards everything from the original error except the text.”. We are therefore able to change any part of the error returned without causing any backwards incompatible changes, assuming users aren’t relying on the string contents of these errors.</p>

<p>Let’s now alter this example to return a structured, unwrappable error:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type PathParseError struct {
  Path string
}
func (e *PathParseError) Error() string {
  return e.Path + ": could not be parsed"
}

// ...

func Decompress(name, path string) error {
  err := &amp;PathParseError{Path: path}
  if err != nil {
    return fmt.Errorf("decompress %v: %w", name, err)
  }
  // ...
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">We've now given</code> users powerful new capabilities for introspecting the returned error. Users now have structured information that they can rely on at runtime, such as the existence of PathParseError, and its fields; whereas before they could only string match the error contents, a practice that is usually discouraged.</p>

<p>But exposing that information to users comes with responsibility. When we only return unstructured errors, we often can be liberal in changing the string-only contents of our errors. However, when we return structured errors to users, we have to be more careful: removing the %w, or changing its value, will be noticeable behavior changes that affect how user code will interpret the returned error.</p>

<p>The subtlety here is that though the structure of the returned error changes when we remove %w or change its value, the type information remains the same - we still just return an error, not noticing that its underlying information has changed. Therefore users won’t observe these changes at compile time: they’ll observe them at run time.</p>

<p>To combat this, here are some tips:</p>

<ul>
  <li>Users should only rely on structured errors from stable libraries that they trust not to change.</li>
  <li>Authors of stable libraries should aim to preserve the behavior of their structured error returns. They should write tests that exercise all observable behavior to aid in that goal, and document which structured errors users can expect to interpret the returned error as.</li>
</ul>

<h1 id="wrapping-external-library-errors">Wrapping external library errors</h1>

<p>Let’s take this example a bit further by wrapping errors from external libraries in our code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package externaldep

type PathParseError struct {
  Path string
}

func ParsePath(path string) (string, error) {
  // ...
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package mycode

func Decompress(name, path string) error {
  _, err := externaldep.ParsePath(path)
  if err != nil {
      return fmt.Errorf("decompress %v: %w", name, err)
  }
  // ...
}
</code></pre></div></div>

<p>As before, we have added to our public API by wrapping <code class="language-plaintext highlighter-rouge">externaldep.PathParseError</code> and returning it as our error. And as before, users can introspect the error we return and get an <code class="language-plaintext highlighter-rouge">externaldep.PathParseError</code>. But, <code class="language-plaintext highlighter-rouge">externaldep.PathParseError</code> lives in an external library - we have no control over it! Our users can now be broken by those external authors in the same ways we described above, without any type information changing.</p>

<p>These behavior changes can cause user breakages. The further that breakage happens from the user code, the harder it will be for the user to understand and debug. Each successive layer of external library error wrapping is an entirely different codebase that the debugger has to understand in the context of all the other codebases. The complexity increases quickly!</p>

<p>To combat this, here are some tips:</p>

<ul>
  <li>Users should prefer relying on structured errors closer to them than farther from them. A structured error that is 5 levels of libraries’ wrapping below them has a far greater chance of a breaking behavior change occurring than a structured error 1 level below them.</li>
  <li>Users should prefer relying on structured errors whose chain never relies on an unstable library.</li>
  <li>Authors of libraries should prefer not to wrap external library errors, unless the use case has well understood value and the external library is stable.</li>
</ul>

<h1 id="unwrap-is-part-of-your-public-api">Unwrap is part of your public API</h1>

<p>We’ve talked about the fact that wrapping errors changes the behavior of your public API. Let’s now discuss Unwrap, and how it can subtly become part of your public API.</p>

<p>When you return a structured error with an Unwrap method, users can use As, Is, and the Unwrap interface to introspect it and errors below it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>err := Decompress(name, path)
if errors.Is(err, PathParseError) {
    // err, or some error that it wraps, is a path parse problem
}
</code></pre></div></div>

<p>Users may not be aware of new layers being added to the chain of errors:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type decompressErr struct {
  name string
  err error
}

func (e *decompressErr) Error() string {
  return fmt.Sprintf("decompress %s: %s", e.name, e.err)  
}

func (e *decompressErr) Unwrap() error { return e.err }

func Decompress(name, path string) error {
  _, err := externaldep.ParsePath(path)
  if err != nil {
      return &amp;decompressErr{name: name, err: err}
  }
  // ...
}
</code></pre></div></div>

<p>Here, we’ve added an intermediary decompressErr. This might be useful somewhere else in our code that calls Decompress, but since it’s un-exported, users have no way to use it for introspection.</p>

<p>But, even though it’s un-exported, the Unwrap method is part of our public API. If we remove the Unwrap method, for example, the errors.Is example breaks: there is no Unwrap link between the returned error and the externaldep.PathParseError. Similarly, if we change Unwrap to behave differently, it will constitute a behavior change in our library.</p>

<p>To combat this, here is a tip:</p>

<ul>
  <li>In general, keep Unwrap simple and deterministic. It should just return the underlying error. If you find that your Unwrap logic is non-deterministic, or you need logic in Unwrap, it might be a signal that you shouldn’t be unwrapping.</li>
</ul>

<h1 id="conclusion">Conclusion</h1>

<p>Error wrapping is a powerful tool that provides upstream users a much richer set of functionality for understanding returned to them by downstream libraries. But, it’s important to be aware that supporting wrapped errors comes with responsibility for compatibility, like any other part of your API. And it’s important to consider whether your error type makes sense to be unwrapped at all.</p>

<p>For most code, it’s best to start simple: use %v instead of %w when you annotate errors, and don’t provide Unwrap on your custom error types. Wait until you learn about specific use cases for providing unwrap mechanics, and then carefully consider how to support them. We hope the considerations highlighted in this article help guide that decision.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">4 years</title><link href="http://localhost:4000/2022/01/01/4years.html" rel="alternate" type="text/html" title="4 years" /><published>2022-01-01T00:55:23-07:00</published><updated>2022-01-01T00:55:23-07:00</updated><id>http://localhost:4000/2022/01/01/4years</id><content type="html" xml:base="http://localhost:4000/2022/01/01/4years.html"><![CDATA[<h2 id="reflecting-on-4-years-at-google">Reflecting on 4 years at Google</h2>

<p>I’m stuck on an airplane with a new macbook, which has Steam (plus two games), Spotify, and Visual Studio Code installed. Steam won’t boot into offline mode, and I’m thoroughly bored, so I thought I’d listen to some music and write another “Reflecting on…” post. This is that post!</p>

<p>(Sidenote: I also have a book and a copy of Foreign Affairs, but both got pretty boring after an hour each)</p>

<h2 id="since-we-last-met">Since we last met</h2>

<p>Since I wrote my last “Reflecting on … Google” post, I had role transferred from Developer Programs Engineer (DPE) to Software Engineer (SWE). DPEs are software engineers that are external facing; in my role, that meant a lot of open source programming, and speaking at conferences. SWEs, by contrast, are your traditional in-the-weeds engineers.</p>

<p>I’ve been pretty in the weeds.</p>

<p>As part of my role transfer, I joined NetInfra - network infrastructure. I spent 2 years on that team, and primarily spent my time designing and leading the development of workflow orchestration system. The system stringed (strang?) together various NetInfra forecast, design, execution, and planning systems into a cohesive whole that could forecast network growth, plan for it, and execute changes to Google data centers to handle the growth. Think: forecast YouTube grows by Xxx leads to purchasing X, Y, Z and the instructions for when and where to install them. Lots of bin packing and optimisation solving in that space.</p>

<p>It was interesting, but it was time to move on. After 2 years, I’d had my fill, and moved on to my current team: object file system (ObjFS), the filesystem underpinning Google’s distributed build stack. It’s written in C++, handles significantly more than 1 million QPS, and the org has loads of fantastic mentors.</p>

<p>It’s so far been intense, but good. A great deal of learning - in the domain, certainly, but also about C++ and build systems in general. I’ve thoroughly enjoyed being back in a growth/learning space. I look forward to what the next few years will bring on this team!</p>

<h2 id="covid-and-remote-work">COVID and remote work</h2>

<p>Like a lot of software engineering practices, Google shut offices and shifted to remote work the last two years. We’re slowly coming out of that; next month, most of us are mandated back to the office 3 of 5 days a week.</p>

<p>I was fairly certain that I’d hate remote work prior to COVID. Looking back, it has had some surprising upsides. But, most of the upsides came with living in a house with ample space for a proper office. In constrast, prior to COVID my WFH experiences were almost all the laptop-on-couch sort of experiences that are only good for up to an hour. In short, the remote work experience was not as bad as expected, but I’m glad to be going back to the office. I far prefer the separation of work and personal life; the socialisation; and not having to cook and clean for myself constantly. 🙂</p>

<h2 id="autonomy-and-20ing">Autonomy and 20%ing</h2>

<p>At Google, there’s a “20% policy”: a policy that allows engineers to spend 20% of their time working on whatever they’d like. It has some caveats; the usual “don’t build a business with our resources” type stuff. Some 20% pessimistics will tell you that there is an opportunity cost: your expectations of output aren’t any lower, so you lose <em>time</em> that you could have spent working towards a promotion, or other goals. But, that’s about it: nothing concrete like a pay cut.</p>

<p>I’ve 20%ed continuously since joining Google, and far from being a hindrance to my career, it’s been a huge positive aspect. I’d go so far as to say it’s helped me in my promotion a few years ago, contrary to what 20% pessimists will tell you.</p>

<p>For the last 2 years, I’ve been 20%ing on various Go projects: primarily gorelease, and Google’s internal Go status package (vis-a-vis stubby, grpc). There are a lot of neat aspects of 20%ing, but the one I’ll highlight is the mental health benefit. When you’re working on a product or team for a long time, there are bound to be hard periods; boring periods; uninteresting periods; and so on. The really fantastic thing about 20%ing is that during those periods you always have a “cool” project to fall back on.</p>

<p>I think that over the last 4 years, it’s really helped with burnout. During covid in particular, when I was dealing with the double burnout of uninteresting work and pandemic exhaustion, it was a huge help to have a really cool (to me) and impactful set of projects to look forward to working on. Some weeks I spent more than 20% of my time working on it; recently, on my new team, I’ve spent quite a bit less than 20%. It’s really great having that flexing room: leaning in when you need something fun, leaning out when your “day job” gives you more than enough. I really appreciate working here for that autonomy.</p>

<p>I’ll also add that a subtle perk of 20%ing is not just that you get to work <em>on</em> what you want, but also <em>with whom</em> you want. I’ve had the absolute joy and pleasure of working with people across the world on my 20% work, with whom I would have never interacted normally. These people have taught me a huge amount, and those relationships have endured across the years and sprouted numerous new projects that I could not have foreseen.</p>

<h2 id="breaking-the-go-at-google-world">Breaking the (Go at Google) world</h2>

<p>The Go status project I briefly mentioned above, which I’ve been 20%ing on for the better part of the last year, has ended triumphantly but also very excitingly.</p>

<p>Google’s internal repository is a monorepo: all the code lives in a single repository. And, there are no external dependencies: anything external has to be vendored in. And finally, there is only one version of all the code in that repo (including vendored code): HEAD.</p>

<p>So, for example, all the Java apps that depend on Log4J, all depend on the exact same source code (effectively: version). If you need to update Log4J, you have to do it in such a way that none of the tens of thousands of dependors are broken.</p>

<p>That sets the stage for my recent Go status project. The internal Go status library - whose external counterpart is called grpcstatus - is a core library depended upon by 62,000 projects. (Sidenote: really easy to count dependors when everything lives in one repo!)</p>

<p>The Go status library handles extrapolating statuses from errors, and turning statuses into errors. Statuses are stubby and gRPC’s means of communicating error information between and across RPC boundaries. In short: it’s the library that you use to describe errors in RPC contexts.</p>

<p>My project was to update this library to play nicely with Go 1.13 errors. It involved a substantial refactor of the library. It had to be done in such a way as not to break the 62,000 dependors. We (my reviewers and I) spent a lot of time (and effort) making sure the changes don’t break anyone. We were <em>very</em> close, but one small auxiliary change in a sister library, around a feature that was depressingly untested, led to catastrophe. The change caused services to lose data over the wire. <em>Realllll bad</em>.</p>

<p>Well, I used the word catastrophe, but that’s a strong word. A handful of people - including myself - freaked out for a short period of time, quickly fixed things (in 25h), and wrote a post-mortem about it. Most of the library users didn’t notice anything.</p>

<p>It took me a long time to describe the situation enough to reflect on it. 🙂</p>

<p>I think that at many companies, the above would have led to firings. At some better companies, it would have only been some moderate yelling at. What happened at Google was fantastic: everyone took a problem solving attitude, identified and fixed the issue with professional demeanor, and wrote a blameless post-mortem whose action items will prevent it from happening again. My manager was extremely supportive and offered me several days off after the incident. My colleagues applauded the fast reaction time, and normalised the experience by commiserating with their own stories of “breaking Google”.</p>

<p>The postmortem we wrote identified several non-human reasons for the failure (namely: severe under-testing, as in O(100s) more tests after we were done than when we started). It also identified several action items for avoiding this issue in the future.</p>

<p>Knowing that even in <em>the worst case scenario</em>, you’re safe and secure in your job, and you’ll be supported to continue finding solutions and fixing problems, is a really special feeling. One of the things keeping me here is the sense of autonomy I described in the section above. But pairing that autonomy with this sense of safety is a very special circumstance.</p>

<h2 id="airplane-writing">Airplane writing</h2>

<p>This article ended up being a bit ramble-y, a side-of-fire story mix of recollection and reflection. I suppose that’s what aimless airplane writing looks like.</p>

<p>I’m still very happy here; I’m learning and growing my technical skills a lot; and I’m having fun. And sometimes unintentionally breaking things, but then fixing them very quickly afterwards.</p>

<p>I had hoped that I would be able to stick on the technical path through my whole career, growing and reaching new levels without having to dip into management. After 4 years at Google, 10 years working professionally, and 16 years programming, I’m very pleased to say that I still have that hope, am still enjoying learning, and doing so voraciously, and am still finding new levels of technical depth. I am overwhelmingly optimistic about continuing on this path. 🙂</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Reflecting on 4 years at Google]]></summary></entry><entry><title type="html">Contexts and Structs</title><link href="http://localhost:4000/2021/02/24/contexts-structs.html" rel="alternate" type="text/html" title="Contexts and Structs" /><published>2021-02-24T14:55:23-07:00</published><updated>2021-02-24T14:55:23-07:00</updated><id>http://localhost:4000/2021/02/24/contexts-structs</id><content type="html" xml:base="http://localhost:4000/2021/02/24/contexts-structs.html"><![CDATA[<p>Posted at <a href="https://go.dev/blog/context-and-structs">go.dev/blog/context-and-structs</a>.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Posted at go.dev/blog/context-and-structs.]]></summary></entry></feed>