<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="jadekler.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="jadekler.github.io/" rel="alternate" type="text/html" /><updated>2019-09-16T21:43:49-06:00</updated><id>jadekler.github.io/feed.xml</id><title type="html">Jean de Klerk</title><subtitle>This is my personal website. The views represented here are my own, and do not represent my employer.</subtitle><entry><title type="html">Reflecting on interviewing at Google</title><link href="jadekler.github.io/2019/09/01/reflecting-on-interviewing-at-google.html" rel="alternate" type="text/html" title="Reflecting on interviewing at Google" /><published>2019-09-01T15:55:23-06:00</published><updated>2019-09-01T15:55:23-06:00</updated><id>jadekler.github.io/2019/09/01/reflecting-on-interviewing-at-google</id><content type="html" xml:base="jadekler.github.io/2019/09/01/reflecting-on-interviewing-at-google.html">&lt;p&gt;Disclaimer: This document makes statements and gives advice about interviewing
at Google. This is &lt;em&gt;not at all&lt;/em&gt; an official accounting of what it’s like to
interview at Google. This is entirely my own interpration, likely riddled with
inaccuracies to the extent that a Googler in recruitment would probably develop
a migraine reading this. If you’d like the official word, check out
careers.google.com or talk to a recruiter.&lt;/p&gt;

&lt;p&gt;Foreword: SWE is an abbreviation for Software Engineer and is often pronounced
“swee”.&lt;/p&gt;

&lt;h1 id=&quot;aiming-high&quot;&gt;Aiming high&lt;/h1&gt;

&lt;p&gt;For me, the ultimate goal has always been Google.&lt;/p&gt;

&lt;p&gt;I began programming during Ms. Roszko’s Computer Science I course in my
sophomore year of high school. I graduated university seven years later with
degrees in Math and Computer Science. Sometime between then, I had convinced
myself that the pinnacle of a career in computer science was a job at Google.&lt;/p&gt;

&lt;p&gt;I’m not sure why. Perhaps the infamously hard interview process, which seemed to
accept only the best of the best. Perhaps the reputably sky-high salaries. Or,
most likely it was that the work was that special kind of interesting and
challenging that all engineers yearn for. The kind of work that you are trained
to do in university - implementing red-black trees; modifying Djikstra’s
algorithm to suit some arcane need; or coming up with some novel algorithm. The
kind of work that hardly any other job seemed to offer; certainly not my
internships up to that point, which all centered around writing websites in some
form or another.&lt;/p&gt;

&lt;p&gt;I got my first interview at Google during my senior year of university and
promptly failed it.&lt;/p&gt;

&lt;h1 id=&quot;interviews-and-exams&quot;&gt;Interviews and exams&lt;/h1&gt;

&lt;p&gt;In a traditional company, the programming interview process goes something like
this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;You write a compelling one-page resume, trying to condense your work
experience whilst using all buzz words that might be Ctrl-F’ed by a recruiter.&lt;/li&gt;
  &lt;li&gt;You apply for a specific job on a specific team.&lt;/li&gt;
  &lt;li&gt;Recruiting team Yea/Nay depending on whether you have the right mix of
buzzwords and years experience.&lt;/li&gt;
  &lt;li&gt;If they Yea, you get a phone call talking about the job and the interview
process.&lt;/li&gt;
  &lt;li&gt;Then, you usually do one phone interview with an engineer or manager which
is designed to vet out the incompetent and clearly poor fits.&lt;/li&gt;
  &lt;li&gt;If you make it past this, you’re usually invited onsite for something like a
half or full day. It’s usually comprised of you being asked about things on
your resume, about how you would tackle imaginary problems, and to
solve contrived problems - or perhaps even solve a real problem. All the while
you’re usually evaluated on some fuzzy criteria of “intelligence” and
“actually knows wtf they are doing” and “would i want to work with this
person”.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It’s a very imperfect process, but it seems to work OK-ish for a lot of
companies.&lt;/p&gt;

&lt;p&gt;Google’s is much more academic, exam-like. It looks something like this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;You write a resume that will be scanned for minimum qualifications and then
largely ignored.&lt;/li&gt;
  &lt;li&gt;You apply for a role (ex SWE) with no idea of which team you might be placed in.&lt;/li&gt;
  &lt;li&gt;Phone interview with recruiter which lays out the next steps.&lt;/li&gt;
  &lt;li&gt;45m technical phone interview with a randomly-selected SWE. You’re writing
code straight into Google Docs. The interview question is usually hard but
not mind-blowingly hard. The format is exam-like: you’re posed a single
question and then asked to solve it. If you succeed, the question is altered
slightly to be harder, and then you’re asked to alter your solution to solve
the new version of the question.&lt;/li&gt;
  &lt;li&gt;Next, you may be asked to perform another 45m technical phone interview if
your last one was borderline.&lt;/li&gt;
  &lt;li&gt;Next, you make it to the onsite. Huzzah! The onsite is 5 in-person 45m
technical interviews at a Google campus. Each of the 45m interviews is once
again exam-like, and usually a bit harder than the phone interview. You’re
being asked questions you’d expect on a computer science exam: answers usually
involve things like Minimum Spanning Trees, Heaps, clever bit manipulations,
and so on. The solution is “coded up” on the whiteboard. Each interviewer is
selected largely at random from a pool of SWE interviewers.&lt;/li&gt;
  &lt;li&gt;Finally, all data from interviews is collated and sent to a hiring committee.&lt;/li&gt;
  &lt;li&gt;If the hiring committee Yeas you, you work with the recruiter to pick a team.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most people take somewhere between 2 weeks to 3 months to study before
attempting the interview (exam).&lt;/p&gt;

&lt;p&gt;If you fail anywhere in the process, you must wait one year before being allowed
to repeat the process.&lt;/p&gt;

&lt;h1 id=&quot;failing-and-failure&quot;&gt;Failing and failure&lt;/h1&gt;

&lt;p&gt;My first failure was in 2013 - my senior year of university.&lt;/p&gt;

&lt;p&gt;After that failure, I became determined to get better - to &lt;em&gt;be&lt;/em&gt; better. I had
a minimum bar for myself and a singular goal I could focus on. One year later in
2014 I re-took the exam and failed again. I did so again in 2015, again in 2016,
and finally in 2017 I made it through. Each year I spent around 2 months
preparing for the interview.&lt;/p&gt;

&lt;p&gt;I believe two things changed in ways that helped me get through the interview.&lt;/p&gt;

&lt;p&gt;The first is that after failing the SWE interview in 2016 the recruiter
suggested I try interviewing for a Developer Programs Engineer (DPE) role. The DPE role was
described as a more open-source and developers focused role, as opposed to the
only-software-all-the-time focused SWE role. It was still in engineering, and
still involved programming, but the interview was slightly different.&lt;/p&gt;

&lt;p&gt;I was all for it, figuring that my several years of open source contribution at
that point might give me an edge, and that if I didn’t like it I could probably
switch to a SWE role internally.&lt;/p&gt;

&lt;p&gt;So, after accepting the idea, I was immediately fast-tracked into an
onsite DPE interview a few weeks after that failure. I promptly failed the DPE
interview, too. But! The interviewer said “You were close!”. So, that was nice.&lt;/p&gt;

&lt;p&gt;The interview didn’t differ much, except that one or two of the onsite questions
was geared towards open source. A question that I remember, for example, is to
explain in detail how dockerization works from the kernel up to the user facing
pieces. The remaining three or four questions were still the usual solve-a-hard-problem
whiteboard types.&lt;/p&gt;

&lt;p&gt;In 2017, I gave the DPE interview another go and succeeded. The open source parts
of the interview were focused on Go - a programming language I had been using
since 2013, and had been active in the community for some time at that point.
It helped that I was very familiar with the subject at that point.&lt;/p&gt;

&lt;p&gt;The other part that changed is my method to preparing for interviews.&lt;/p&gt;

&lt;h1 id=&quot;interview-preparation&quot;&gt;Interview preparation&lt;/h1&gt;

&lt;p&gt;There’s about 6 ways you can prepare for a technical interview:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Memorize algorithms and data structures.&lt;/li&gt;
  &lt;li&gt;Solve contrived problems on leetcode.com / hackerrank.com / &lt;em&gt;Cracking The
Coding Interview&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;Read computer science books (such as Skiena’s &lt;em&gt;Algorithm Design Manual&lt;/em&gt;).&lt;/li&gt;
  &lt;li&gt;Take a computer science course (or, be a student already taking one).&lt;/li&gt;
  &lt;li&gt;Perform real or mock interviews.&lt;/li&gt;
  &lt;li&gt;Do hard, Computer-Science-y things regularly (like, as part of your job).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For the majority of my interviews during my career, I had focused on the first
two: memorization and solving contrived problems. In retrospect, these did
little for me except make me more anxious. I had trouble retaining the knowledge
for more than a day or two: without putting any of it into actual practice, it
seemed to just evaporate.&lt;/p&gt;

&lt;p&gt;I’d also been taking interviews at companies since graduating - even when
happily employed. I figured the longer you go without interviewing, the more
nerve-racking it becomes, and the more out of practice you become, so why not
interview once or twice a year just to keep in the swing of it. This helped
me be more at-ease during interviews, but ultimately I was lacking mastery of
the subjects.&lt;/p&gt;

&lt;p&gt;Note: an ideal situation is that your day-to-day job involves the kind of
hard problems that you’d find in a Google interview. That’s a pipe dream for
most developers, though: an overwhelming majority of software development is
pretty banal implementation of web applications, mobile applications, or some
piping-of-data in the backend applications. Loads of engineering, surely, but
not really Computer Science.&lt;/p&gt;

&lt;p&gt;In 2017 I started a Computer Science Master’s program through Georgia Institute
of Technology (Georgia Tech). It was at the time a novel online course, well
reputed for being extremely rigorous despite being online, and offering an
actual Master of Science degree. (It has since become very popular, and has
instigated a wave of similar programs from other top universities.)&lt;/p&gt;

&lt;p&gt;The classes I took were Computer Vision, Building Problem-Solving AIs, and
Computer Networking. Each class had intensive projects that forced me to learn
and re-learn large parts of Math and Computer Science. They were also extremely
well taught, and very, very fun. The AI course, for example, had you build a
game-playing AI that you could pit against other classmates’ AIs.&lt;/p&gt;

&lt;p&gt;This type of atmosphere allowed for experimentation and competition, and
rewarded both broad use of many Computer Science topics as well as deep dives.
It was for me the perfect way to get back in the academic mindset; to master
Computer Science and math topics; and ultimately to prepare for the interview.&lt;/p&gt;

&lt;p&gt;As the interview process began again that year, I supplemented it with basic
familiarity with a wide number of algorithms taken from books, as well as a few
mock interviews.&lt;/p&gt;

&lt;p&gt;It seemed to work: I got an offer sometime around October of 2017.&lt;/p&gt;

&lt;p&gt;Or, maybe they got sick and tired of me interviewing five years running. :)
There’s something to be said for stubborn will!&lt;/p&gt;

&lt;h1 id=&quot;repeating-the-miracle&quot;&gt;Repeating the miracle&lt;/h1&gt;

&lt;p&gt;If I had to do it all again, or give advice to someone starting the process,
here’s what I’d suggest:&lt;/p&gt;

&lt;p&gt;First, don’t pin all your hopes on Google. The acceptance rate is less than
Harvard by an order of magnitude: the numbers aren’t really in your favour.
Once you make peace with that, the rest comes a lot easier.&lt;/p&gt;

&lt;p&gt;The good news is that if you do convince yourself to study for Google, you will
&lt;em&gt;crush&lt;/em&gt; every other interview you take. Google requires such an obscenely high
level of preparation that it makes other interviews look like child play. So,
apply to Google, but also look for other jobs that would interest you: you will
never be more prepared to interview for them.&lt;/p&gt;

&lt;p&gt;Another piece of good news is that the difference between a rejection and a
success is mostly the preparation that goes into the candidate. There is
certainly some luck involved, and being naturally gifted always helps, but
mostly practice - smart practice - is what sets good candidates apart from
the rest.&lt;/p&gt;

&lt;p&gt;One more piece of good news is that Google goes to great lengths to make the
process as unbiased as possible. That means, you’re not on the hook for trying
to buddy up to the person interviewing you. It also means that the differences
between you and the person interviewing you - be it cultural background, or
viewpoints, or any other differentiating factor - are totally irrelevant. You’re
only being evaluated on your objective performance.&lt;/p&gt;

&lt;p&gt;So, in conclusion, I think that the real secret sauce is choosing a study
schedule that fits healthily into your life - rather than obsessing about
getting &lt;em&gt;this one job&lt;/em&gt; - and choosing a method of study that works for you.
Every person learns differently, and retains knowledge differently. Some of my
colleagues swear by working on practice problems, whilst I strongly prefer the
approach of taking courses and completing homework / projects.&lt;/p&gt;

&lt;p&gt;Consider the list of interview prepation techniques above and do some
introspection about how you learn best. And, if you can, try to orient your
job around interesting problems that push you to learn, rather than staying
in your comfort zone.&lt;/p&gt;</content><author><name></name></author><summary type="html">Disclaimer: This document makes statements and gives advice about interviewing at Google. This is not at all an official accounting of what it’s like to interview at Google. This is entirely my own interpration, likely riddled with inaccuracies to the extent that a Googler in recruitment would probably develop a migraine reading this. If you’d like the official word, check out careers.google.com or talk to a recruiter.</summary></entry><entry><title type="html">Reflecting on two years at Google</title><link href="jadekler.github.io/2019/09/01/reflecting-on-two-years-at-google.html" rel="alternate" type="text/html" title="Reflecting on two years at Google" /><published>2019-09-01T15:55:23-06:00</published><updated>2019-09-01T15:55:23-06:00</updated><id>jadekler.github.io/2019/09/01/reflecting-on-two-years-at-google</id><content type="html" xml:base="jadekler.github.io/2019/09/01/reflecting-on-two-years-at-google.html">&lt;p&gt;I had meant to write a &lt;em&gt;“Reflecting on one year at Google”&lt;/em&gt; post earlier this
year, but it kept getting put off until suddenly I realized that it would be
better to just cut my losses and skip to the second year post.&lt;/p&gt;

&lt;p&gt;Then, when I got into it, I realized that a lot of my experience with Google
was from the outside: failing repeatedly trying to get in. So, after writing a
bunch about that, I decided to create two posts: &lt;em&gt;&lt;a href=&quot;/2019/09/01/reflecting-on-interviewing-at-google&quot;&gt;“Reflecting on interviewing
at Google”&lt;/a&gt;&lt;/em&gt; and this post.&lt;/p&gt;

&lt;p&gt;Now, with all that out the way, I’m finally read to really dig in and start some
serious reflection and introspection.&lt;/p&gt;

&lt;p&gt;Background note: I started at Google in late 2017. I moved from Colorado to
California (San Francisco bay area) for the job, and moved back to Colorado
in early 2018 (keeping the job, but working from Boulder, Colorado).&lt;/p&gt;

&lt;h1 id=&quot;small-steps&quot;&gt;Small steps&lt;/h1&gt;

&lt;p&gt;Starting at Google was unlike any other job. Most jobs I’ve had, and heard
about, followed a pattern of a 2-week break-in period followed by a few
months contributing but still kind-of trying to get caught up, followed by
proficiency, and at some point later you might lead a team.&lt;/p&gt;

&lt;p&gt;Google was very much not like that. You start by attending at 2 week
orientation with the other ~400-700 people in your “Noogler” class. Yes,
&lt;em&gt;hundreds&lt;/em&gt; of people - mostly engineers - start at Google every two weeks.
On one campus. More on other campuses. Mind blown.&lt;/p&gt;

&lt;p&gt;The first two weeks are spent in lectures and seminars repeatedly having your
sense of scale and proportion obliterated, being exposed to various systems and teams
within the company, being taught taught by senior
engineers how to use some of these systems, and generally being taught how to
teach yourself.&lt;/p&gt;

&lt;p&gt;In your third week you’re ready to meet your team. Your team introduces you to
a “starter project”: a small project in a well-understood area that you can use
to feel good about yourself, and hopefully along the way learn how to actually
start writing and releasing code. You’re given something like a month to finish
this.&lt;/p&gt;

&lt;p&gt;So, it takes &lt;em&gt;6 weeks after you start&lt;/em&gt; before you’re actually ready to look at
real code. And, beyond that, most teams will only expect you to be a
fully independent, contributing team member somewhere around month 6 to 9.&lt;/p&gt;

&lt;h1 id=&quot;inch-by-inch&quot;&gt;Inch by inch&lt;/h1&gt;

&lt;p&gt;My first actually-useful piece of code I submitted, if I recall correctly, was
a code sample that showed developers how to use the Pub/Sub client library in
a certain way.&lt;/p&gt;

&lt;p&gt;All code at Google goes through a process called “code review”, where code
changes (or additions, deletions) get “proposed” and reviewed by colleagues,
who either Yea, Nay, or ask for changes. This is a fairly common practice in
software engineering. It varies a lot by company. At most companies, code review
usually something like 30 minutes to 2 days per code change. Code reviews at
most companies are typically fairly high-level, and tend to concern themselves
with broad design or nit-picky things like code style.&lt;/p&gt;

&lt;p&gt;That first change I proposed took something like &lt;em&gt;two weeks&lt;/em&gt; to get through
code review. I learned more about Go and code design during that code review
than I’d experienced the entire past year leading up to that point (which is
not that high of a bar, if you know my prior experiences, but still). It was
brutal. My code was picked apart; it was analyzed line-by-line, and then
block-by-block, and then file-by-file. It wasn’t malicious, though: code review
comments were statements of fact, or impartial queries, rather than jabs and
one-ups. They were, “This can be more performant like so: |example|. And,
here’s why: |reason|.”, not “This is terrible. Do it this way: |example|.”.&lt;/p&gt;

&lt;p&gt;After years of stagnation in my career at that point it was so wonderful to
be learning again, from people with a deep wealth of knowledge and
experience. I was hooked.&lt;/p&gt;

&lt;p&gt;The next year was a lot of this. I got better by inches: by treating each code
review as a learning opportunity; by diving into problems I had no business
being in; by pushing myself, over, and over, and over, to become better.&lt;/p&gt;

&lt;p&gt;Looking back, I was getting better: the scope of problems continually increased;
the code reviews went from weeks to hours or days, from everything-under-the-sun
is wrong to fairly-subtle suggestions. I was slowly transitioning from a student
that needed hand-holding, and didn’t provide much in return, to a colleague that
accepted and gave equally (or, closer to equal).&lt;/p&gt;

&lt;h1 id=&quot;metre-by-unhealthy-metre&quot;&gt;Metre by unhealthy metre&lt;/h1&gt;

&lt;p&gt;My intense passion for interesting problems and self-improvement finally had an
outlet, and that outlet was unbounded in scope. Worse: it rewarded the effort
I put in: despite my increasing weariness, the scope of my work constantly
increased (by my own volition); my personal reviews were stellar; and my
projects were almost universally a success.&lt;/p&gt;

&lt;p&gt;I didn’t realize until fairly late that I was slowly grinding myself down to the
bone. I was working 10, 12, or 14 hour days, and often would work on weekends.
I took my frustrations and problems home rather than leaving them at work; they
were compounded with my increasing dislike of California.&lt;/p&gt;

&lt;p&gt;I ended up getting most of the way through that first year before realizing some
things were very bad. For the first time in my life, I recognized signs of
depression. Some combination of a too-intense work schedule, longing for my
old friends and outdoor-focused lifestyle in Colorado, and relationship problems
were causing me to be deeply unhappy.&lt;/p&gt;

&lt;p&gt;I won’t get into that part too much. The long story short is that I had a bit of
a break down and decided I needed to move back to Colorado, Google or no Google.
Thankfully, my department was and is fantastic and thoroughly supported me, and
offered me my job at the Colorado campus with a standard cost-of-living pay reduction.&lt;/p&gt;

&lt;p&gt;I moved back to Colorado in early 2018 with the same job.&lt;/p&gt;

&lt;h1 id=&quot;on-to-the-other-side&quot;&gt;On to the other side&lt;/h1&gt;

&lt;p&gt;The year taught me a lot about my limits to an extent that’s hard to put into
words. I’ve learned how to spot signs of too much stress, healthy coping
mechanisms, and how to set boundaries. I’ve learned a lot about what I value,
and the type of life I want for myself. And, it’s helped me refine the kind of
person I want to be: hard-working and respected in my career, yes, but also a kind
friend with space in my life to help others; a well-rounded individual with lots
of time spent outdoors; a good partner. It’s hard not to wish I had had these
skills going into the job. It would have saved a lot of hardship for myself and
my relationship at the time. I suppose the best you can do is try to learn from
hardship, though, and try to become better for it.&lt;/p&gt;

&lt;p&gt;In the last year I’ve committed myself to a healthy balance of passion for my
job and all the rest that matter to me: loving relationships with friends and
family; spending time in nature; sports and exercise; hobbies like reading and
taking french lessons; and progressing my “adult” life with things like buying
a house and building a local community.&lt;/p&gt;

&lt;p&gt;My work hasn’t suffered hardly as much as I thought it would. Working 7 to
8 hours a day has made me be a lot more efficient with my time: I cancel or
decline a lot more meetings; I don’t take hour-long lunches with colleagues;
I don’t do a lot of after-work events; I delegate a lot more rather than
“superhero” all the work myself. And, the reprecussions never came: my lessened
throughput was celebrated by my manager and team as mental health successes,
rather than the disappointment I was subconsiously bracing myself for.&lt;/p&gt;

&lt;p&gt;The outcome is a much healthier, happier day-to-day, week-to-week. I once
again find self-value in things outside of work; I have a robust and healthy
support system of friends and family; I progress myself in sports and hobbies
so that stalls or failures at work at diminished in impact by successes
elsewhere.&lt;/p&gt;

&lt;h1 id=&quot;keeping-perspective&quot;&gt;Keeping perspective&lt;/h1&gt;

&lt;p&gt;I’ve had the privilege and honour of working with incredible minds, who have
universally been kind and willing to teach. I’ve sat in rooms with people that
have invented entire languages, network protocols, and algorithms for systems
at scale. I’ve had my opinions heard and sincerely considered by these people,
and had the opportunity to learn from them. I’ve had the opportunity to lead;
to design; to mentor; and to teach. I’ve accomplished and learned more (in my
own eyes) than in these two years than my entire career before this.&lt;/p&gt;

&lt;p&gt;I’ve also had the honour of having incredible managers and directors. I have
felt since day one that I was a valued member of a team; that my opinions held
weight; that I was supported in whatever I decided was best for myself, even if
that meant leaving the company or my team.&lt;/p&gt;

&lt;p&gt;I work on things that I find really, really cool: building a performance
benchmarking pipeline and improving client library performance; defining the
client-side retry strategy for all of Google Cloud; improving Google Cloud
reliability with throttling and load shedding; building important and complex
features into the libraries; working on the HTTP/2 transport in gRPC; and loads
more. Moreover, I’ve been given a lot of freedom in choosing the kinds of things
I work on, and being encouraged to go find new problems that we’re not aware of
yet.&lt;/p&gt;

&lt;p&gt;I’ve had opportunities to travel around the world, meeting developers, working
with amazing engineers, and giving talks on technical topics. And at home, we
are given a tremendous amount of benefits, too: classes, food,
classes about making food (seriously), gyms, fun events, clubs, and more.&lt;/p&gt;

&lt;p&gt;It’s a good place to work. It’s an intense place to work, and you have to be
very careful not to let it burn you up, but it is a good place to work. I
don’t see myself working anywhere else for the foreseeable future.&lt;/p&gt;</content><author><name></name></author><summary type="html">I had meant to write a “Reflecting on one year at Google” post earlier this year, but it kept getting put off until suddenly I realized that it would be better to just cut my losses and skip to the second year post.</summary></entry><entry><title type="html">Migrating to Go Modules</title><link href="jadekler.github.io/2019/08/21/migrating-to-go-modules.html" rel="alternate" type="text/html" title="Migrating to Go Modules" /><published>2019-08-21T15:55:23-06:00</published><updated>2019-08-21T15:55:23-06:00</updated><id>jadekler.github.io/2019/08/21/migrating-to-go-modules</id><content type="html" xml:base="jadekler.github.io/2019/08/21/migrating-to-go-modules.html">&lt;p&gt;Posted at &lt;a href=&quot;https://blog.golang.org/migrating-to-go-modules&quot;&gt;blog.golang.org&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">Posted at blog.golang.org.</summary></entry><entry><title type="html">Designing CRUD operations in Go</title><link href="jadekler.github.io/2019/06/08/designing-crud-operations-in-go.html" rel="alternate" type="text/html" title="Designing CRUD operations in Go" /><published>2019-06-08T15:55:23-06:00</published><updated>2019-06-08T15:55:23-06:00</updated><id>jadekler.github.io/2019/06/08/designing-crud-operations-in-go</id><content type="html" xml:base="jadekler.github.io/2019/06/08/designing-crud-operations-in-go.html">&lt;p&gt;This post is intended to provide some insight into the considerations that
go into adding CRUD operations in a Go client library.&lt;/p&gt;

&lt;h2 id=&quot;the-problem-ambiguity&quot;&gt;The Problem: Ambiguity&lt;/h2&gt;

&lt;p&gt;Every time we add a new create or update RPC - &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateFoo&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;UpdateFoo&lt;/code&gt; - that
takes parameters, we have to ask the questions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Is it possible to perform a delete a parameter when updating Foo?&lt;/li&gt;
  &lt;li&gt;How should users ignore that parameter when updating Foo?&lt;/li&gt;
  &lt;li&gt;How should users delete that parameter when updating Foo?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Consider the following RPC:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message FooUpdateRequest {
  google.protobuf.Duration ttl = 1;        // When set to 0, deletes TTL.
  google.protobuf.Duration expiration = 2; // When set to 0, deletes expiration.
}

service Foo {
  rpc UpdateFoo(FooUpdateRequest) returns (SomeResponse)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Building a manual layer wrapper around this might look very similar:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type FooConfigToUpdate struct {
  Ttl        time.Duration
  Expiration time.Duration
}

func (f *Foo) Update(ctx context.Context, cfg *FooConfigToUpdate) error {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This seems fairly innocuous, but consider those questions again:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Is it possible to perform a delete a parameter when updating Foo?
A: Yes, both parameters in the .proto definition mention that 0 is used as a delete.&lt;/li&gt;
  &lt;li&gt;How should users ignore that parameter when updating Foo?
A: Set it to time.Duration(0).&lt;/li&gt;
  &lt;li&gt;How should users delete that parameter when updating Foo?
A: Uhh… also set it to time.Duration(0)?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As you can see, there’s currently no way to distinguish between Delete and
Ignore. That is, if a user passes:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f.Update(ctx, &amp;amp;foopkg.FooConfigToUpdate{Expiration: 5 * time.Second})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It’s clear that we need to update Expiration to 5s, but what do we do with ttl?
Its default value is &lt;code class=&quot;highlighter-rouge&quot;&gt;time.Duration(0)&lt;/code&gt; - do we delete it, or ignore it?&lt;/p&gt;

&lt;p&gt;We need a way to get around this. Broadly, there are three options we use in client libraries:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Sentinel values.&lt;/li&gt;
  &lt;li&gt;Pointers.&lt;/li&gt;
  &lt;li&gt;Optionals.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;sentinel-values&quot;&gt;Sentinel Values&lt;/h2&gt;

&lt;p&gt;Sentinel values are basically special values that signal to the client library
to perform special logic. For example, consider:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var NeverExpire time.Duration = -1 * time.Second
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;No user would ever specify -1s as an expiration value, so the library picks that
value as its sentinel. Then, any time the library sees -1s, it knows this is the
special value used to indicate “delete”.&lt;/p&gt;

&lt;p&gt;If the empty value is passed, the library ignores the operation. If the user
passes the sentinel value, the library performs the delete. A user uses the
sentinel to delete as such:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f.Update(ctx, &amp;amp;foopkg.FooConfigToUpdate{Expiration: foopkg.NeverExpire})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;pointers&quot;&gt;Pointers&lt;/h2&gt;

&lt;p&gt;When using pointers, we automatically resolve ambiguity, because beside the
empty value we now also have the nil value.&lt;/p&gt;

&lt;p&gt;The nil value is taken as “ignore this” (unspecified), and the empty value is
taken as “delete this”.&lt;/p&gt;

&lt;p&gt;A user uses the empty value to delete as such:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f.Update(ctx, &amp;amp;foopkg.FooConfigToUpdate{Expiration: &amp;amp;time.Duration(0)})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;optionals&quot;&gt;Optionals&lt;/h2&gt;

&lt;p&gt;Optionals are a Java concept. Without involving pointers, they add an
additional “set or unset” parameter to a value in a similar way that pointers
are set or nil.&lt;/p&gt;

&lt;p&gt;Unlike Java, however, optionals are not part of the stdlib. In
&lt;code class=&quot;highlighter-rouge&quot;&gt;cloud.google.com/go&lt;/code&gt;, we’ve created a very light wrapper around &lt;code class=&quot;highlighter-rouge&quot;&gt;interface{}&lt;/code&gt;
to implement optional types. Since they’re light wrappers around &lt;code class=&quot;highlighter-rouge&quot;&gt;interface{}&lt;/code&gt;,
values are nil-able.&lt;/p&gt;

&lt;p&gt;Like pointers, the nil value is taken as “ignore this” (unspecified), and the
empty value is taken as “delete this”.&lt;/p&gt;

&lt;p&gt;A user uses the empty value to delete as such:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f.Update(ctx, &amp;amp;foopkg.FooConfigToUpdate{Expiration: time.Duration(0)})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;choosing-the-right-solution&quot;&gt;Choosing The Right Solution&lt;/h2&gt;

&lt;p&gt;There are downsides to each solution:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Sentinels add to the API surface, and reduce the range of values users can
use. They are not described by the type system, like pointers: users have to
read docs to find out how to use them. Finally, they may surprise users using
the reserved value without knowing that they are.&lt;/li&gt;
  &lt;li&gt;Pointers only work on types - ints, strings, bools, and other primitives
become quite burdensome to use. Furthermore, pointers can’t be added in a
backwards-compatible fashion, since they change the signature of a
parameter/method.&lt;/li&gt;
  &lt;li&gt;Optionals are untyped (since they’re wrappers around interface{}), and not
idiomatic Go.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On the other hand, the advantages to each solution:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Sentinels can be added in a backwards-compatible fashion, since they don’t
change the signature of a parameter/method.&lt;/li&gt;
  &lt;li&gt;Pointers are very idiomatic to Go, widely used, and their semantics are
encoded in the type system, making them very easy and obvious to use.&lt;/li&gt;
  &lt;li&gt;Optionals can be added (but not removed) in a backwards-compatible fashion,
since their untyped nature is compatible with an pre-existing inputs supplied
by the user.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sentinels should generally be avoided, since we try to minimize API surface
additions. They are commonly used in “uh oh” moments where we have to go amend
a stable client’s API surface in which the to-be-fixed portion is already
released.&lt;/p&gt;

&lt;p&gt;Pointers are generally the preferred choice but fall short on primitive types,
and aren’t backwards-compatible. Optionals are fairly widely used, too.&lt;/p&gt;

&lt;p&gt;In general, it’s best to investigate the client you’re working on and focus on
consistency of choice. Ideally, all clients would be consistent with each other, too.&lt;/p&gt;

&lt;h2 id=&quot;a-note-on--experimental&quot;&gt;A Note On // Experimental&lt;/h2&gt;

&lt;p&gt;Note that if a part of the API surface is marked experimental, the above notes
on backwards compatibility don’t apply. Therefore, if you’re adding to an API
surface and not sure how it’ll evolve over time, opt to add the
&lt;code class=&quot;highlighter-rouge&quot;&gt;// Experimental&lt;/code&gt; tag:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// It is EXPERIMENTAL and subject to change or removal without notice.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">This post is intended to provide some insight into the considerations that go into adding CRUD operations in a Go client library.</summary></entry><entry><title type="html">Resolving Problems From Modified Module Path</title><link href="jadekler.github.io/2019/04/23/resolving-problems-from-modified-module-path.html" rel="alternate" type="text/html" title="Resolving Problems From Modified Module Path" /><published>2019-04-23T15:55:23-06:00</published><updated>2019-04-23T15:55:23-06:00</updated><id>jadekler.github.io/2019/04/23/resolving-problems-from-modified-module-path</id><content type="html" xml:base="jadekler.github.io/2019/04/23/resolving-problems-from-modified-module-path.html">&lt;p&gt;Posted at &lt;a href=&quot;https://github.com/golang/go/wiki/Resolving-Problems-From-Modified-Module-Path&quot;&gt;github.com/golang/go/wiki&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">Posted at github.com/golang/go/wiki.</summary></entry><entry><title type="html">Multi-Module Repositories</title><link href="jadekler.github.io/2019/02/25/multi-module-repositories.html" rel="alternate" type="text/html" title="Multi-Module Repositories" /><published>2019-02-25T14:55:23-07:00</published><updated>2019-02-25T14:55:23-07:00</updated><id>jadekler.github.io/2019/02/25/multi-module-repositories</id><content type="html" xml:base="jadekler.github.io/2019/02/25/multi-module-repositories.html">&lt;p&gt;Posted at &lt;a href=&quot;https://github.com/golang/go/wiki/Modules#faqs--multi-module-repositories&quot;&gt;github.com/golang/go/wiki&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">Posted at github.com/golang/go/wiki.</summary></entry><entry><title type="html">gRPC on HTTP/2: Engineering a Robust, High Performance Protocol</title><link href="jadekler.github.io/2018/08/20/grpc-on-http.html" rel="alternate" type="text/html" title="gRPC on HTTP/2: Engineering a Robust, High Performance Protocol" /><published>2018-08-20T15:55:23-06:00</published><updated>2018-08-20T15:55:23-06:00</updated><id>jadekler.github.io/2018/08/20/grpc-on-http</id><content type="html" xml:base="jadekler.github.io/2018/08/20/grpc-on-http.html">&lt;p&gt;Posted on &lt;a href=&quot;https://grpc.io/blog/grpc_on_http2/&quot;&gt;grpc.io&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">Posted on grpc.io.</summary></entry><entry><title type="html">HTTP/2: Smarter At Scale</title><link href="jadekler.github.io/2018/07/21/http2-smarter-at-scale.html" rel="alternate" type="text/html" title="HTTP/2: Smarter At Scale" /><published>2018-07-21T15:55:23-06:00</published><updated>2018-07-21T15:55:23-06:00</updated><id>jadekler.github.io/2018/07/21/http2-smarter-at-scale</id><content type="html" xml:base="jadekler.github.io/2018/07/21/http2-smarter-at-scale.html">&lt;p&gt;Posted at &lt;a href=&quot;https://www.cncf.io/blog/2018/07/03/http-2-smarter-at-scale/&quot;&gt;cncf.io&lt;/a&gt; and &lt;a href=&quot;https://grpc.io/blog/http2_smarter_at_scale/&quot;&gt;grpc.io&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">Posted at cncf.io and grpc.io.</summary></entry><entry><title type="html">Which protocol should I use?</title><link href="jadekler.github.io/2018/03/03/which-protocol-should-i-use.html" rel="alternate" type="text/html" title="Which protocol should I use?" /><published>2018-03-03T14:55:23-07:00</published><updated>2018-03-03T14:55:23-07:00</updated><id>jadekler.github.io/2018/03/03/which-protocol-should-i-use</id><content type="html" xml:base="jadekler.github.io/2018/03/03/which-protocol-should-i-use.html">&lt;p&gt;Posted on &lt;a href=&quot;https://medium.com/@deklerk_22602/which-protocol-should-i-use-d82cb449f065&quot;&gt;medium.com&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">Posted on medium.com.</summary></entry></feed>